"""Container for data, masks, graphics items, annotations logic etc. pp.
related to a single, identifyable thingy in an image stack
"""

class Entity():
    """Base entity derived from image
    should be generated by factory only

    Will be hirachically ordered. Thus might not
    have any functions that prevent an atomic use
    of the entities e.g. as nodes in an hirachical,
    ordered tree
    """

    _used_ids = set([])
    
    def __init__(self, entity_id=None):

        ### Logic ###
        # must be unique, enforced on class level
        # maybe on factory level? nontheless similar logic
        if entity_id is None:
            entity_id = self._get_eid()

        if not self._valid_eid(entity_id):
            raise ValueError('EntityID {} already in use'.format(entity_id))

        self.eid = entity_id

        ### Imagepixel context ###
        # properties of the entity context of
        # pixel based images / sources of data
        # a numpy slice than can be used to get the pixels
        # from the image that belong to the object in each
        # respective channel
        self._slice = (None, None)
        # boolean numpy mask
        # must have same shape as the _slice. Given the of
        # the image returned after slicing, the pixel in the
        # mask being True signify pixels within the slice
        # beeing image pixels
        self._mask = None

        ### View context ###
        # properties of the entity in context of
        # the view of the entity
        # a QRect locating the entity in the scene it is
        # placed in
        self._boundingbox = None
        # QPolygon, giving the polygon of the entity
        # representing it in the view
        self._polygons = None

        ### Common Attributes ###
        # all attributes relevant for drawing
        # like colors, shapes, whatever
        # to be manipulated directly
        self.attributes = {}

        ### Data ###
        # all the stuff that is data related
        # like annotation and derived values/scalars
        # can be manipulated directly
        self.tags = []
        self.scalars = {}

    def _set_mask(self, polygon):
        """Sets the mask, given the polygon
        """
        pass

    def _set_polygon(self, mask, eslice):
        """Sets the polygon, given the bool mask for the eslice
        where bool mask is a np.array and eslice a tupple of slices
        """
        pass

    @classmethod
    def get_eid(cls):
        pass


    def set_free_oid(self, new_object):
        """Sets oid to a free one. if new_objects
        id is not taken, it stays

        Raises
        ------
        ValueError : if no map was loaded
        """
        if self._objid_map is None:
            raise ValueError('No map was loaded or created!')

        other = self._objects_dict.get(new_object.id, None)
        if other is None:
            return

        # def find_missing(d):
        left = 0
        right = len(self.objects) - 1

        if self.objects[right].id == len(self.objects):
            self._log.debug('fast free id')
            new_object.id = len(self.objects) + 1

        if self.objects[left].id != 1:
            self._log.debug('fast free id')
            new_object.id = 1

        while True:
            mid = left + (right - left) // 2
            val = self.objects[mid].id - 1
            if val != mid:
                right = mid
            else:
                left = mid
            if right - left == 1:
                break

        lval = self.objects[left].id
        rval = self.objects[right].id

        if rval - lval <= 1:
            self._log.debug('missed...')
            return len(self.objects) + 1

        new_object.id = lval + 1
